package main

import (
	"encoding/json"
	"log"
	"os"
	"path/filepath"
	"strings"
	"text/template"
)

type Collection struct {
	Item []Item `json:"item"`
}

type Item struct {
	Name    string   `json:"name"`
	Request *Request `json:"request,omitempty"`
	Item    []Item   `json:"item,omitempty"`
}

type Request struct {
	Method string `json:"method"`
	URL    URL    `json:"url"`
}

type URL struct {
	Raw string `json:"raw"`
}

type Endpoint struct {
	FuncName string
	Method   string
	Path     string
}

func main() {
	data, err := os.ReadFile(filepath.Join("..", "postman.json"))
	if err != nil {
		log.Fatalf("read postman.json: %v", err)
	}
	var c Collection
	if err := json.Unmarshal(data, &c); err != nil {
		log.Fatalf("unmarshal postman collection: %v", err)
	}
	var eps []Endpoint
	walkItems(c.Item, &eps)

	tmpl := template.Must(template.New("sdk").Parse(`// Code generated by cmd/gen/main.go; DO NOT EDIT.

package sdk

import (
    "context"
    "net/http"
)

{{range .}}
// {{.FuncName}} calls the {{.Path}} endpoint using the {{.Method}} method.
func (c *Client) {{.FuncName}}(ctx context.Context) (*http.Response, error) {
    req, err := c.newRequest(ctx, http.Method{{.Method}}, "{{.Path}}", nil)
    if err != nil {
        return nil, err
    }
    return c.httpClient.Do(req)
}

{{end}}
`))

	f, err := os.Create("generated.go")
	if err != nil {
		log.Fatalf("create generated.go: %v", err)
	}
	defer f.Close()
	if err := tmpl.Execute(f, eps); err != nil {
		log.Fatalf("execute template: %v", err)
	}
}

func walkItems(items []Item, eps *[]Endpoint) {
	for _, it := range items {
		if it.Request != nil {
			method := strings.Title(strings.ToLower(it.Request.Method))
			path := strings.Replace(it.Request.URL.Raw, "{{baseUrl}}", "", 1)
			path = strings.TrimSpace(path)
			name := strings.ReplaceAll(it.Name, " ", "")
			name = strings.Title(name)
			*eps = append(*eps, Endpoint{FuncName: name, Method: method, Path: path})
		}
		if len(it.Item) > 0 {
			walkItems(it.Item, eps)
		}
	}
}
